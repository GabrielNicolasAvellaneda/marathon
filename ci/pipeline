#!/usr/bin/env amm

import ammonite.ops._
import ammonite.ops.ImplicitWd._
import java.util.concurrent.TimeUnit
import scala.concurrent.duration._
import scala.util.control.NonFatal
import scala.util.Try

import $file.awsClient
import $file.fileUtil
import $file.phabricatorClient
import $file.provision
import $file.upgrade
import $file.utils

val PACKAGE_DIR: Path = pwd / 'target / 'universal

/**
 * Compile Marathon and run unit and integration tests followed by scapegoat.
 */
@main
def compileAndTest(): Unit = utils.stage("Compile and Test") {

  def run(cmd: String *) = utils.runWithTimeout(1.hour)(cmd)

  run("sbt", "clean", "test", "integration:test", "scapegoat")

  // Compile other projects.
  run("sbt", "benchmark/compile")
  run("sbt", "mesos-simulation/compile")
  run("sbt", "plugin-interface/compile")
}

@main
def zipSandboxLogs(): Unit = {
  Try(%("tar", "-zcvf", "sandboxes.tar.gz", "sandboxes"))
}

@main
/**
 * Upload different Marathon tarballs and their cha1 checksum to S3.
 *
 * @return Map from tarball type to artifact description.
 */
def uploadPackagesToS3(): Map[String, awsClient.Artifact]= utils.stage("Upload Packages") {
  import scala.collection.breakOut

  (ls! PACKAGE_DIR |? (file => file.ext == "tgz" || file.ext == "txz" ))
    .map( file => file.ext -> awsClient.archiveArtifact(file) )(breakOut)
}

@main
/**
 * Packages Marathon and uploads its artifacts alongside sha1 checksum to S3.
 *
 * @return Map for package typ to its artifact description.
 */
def createAndUploadPackages(): Map[String, awsClient.Artifact] = {
  createPackages()
  val artifacts = uploadPackagesToS3()
  createLinuxPackages()
  artifacts
}

/**
 * Creates the zip and txz files of the Marathon runnable package with their
 * associated sha1
 */
@main
def createPackages(): Unit = utils.stage("Package") {
  %('sbt, "universal:packageZipTarball", "universal:packageXzTarball")
}

/**
 * Create Docker, rpm and deb packages.
 */
@main
def createLinuxPackages(): Unit = utils.stage("Package Docker Image, Debian and RedHat Packages") {
  %('sbt, "docker:publishLocal", "packageDebian", "packageRpm")
}

/**
 * The pipeline target for Phabricator builds. It triggers the Jenkins target
 * and does some additional reporting to Phabricator.
 */
@main
def phabricator(): Unit = {
  val diffId: String = sys.env.getOrElse("DIFF_ID", throw new IllegalArgumentException("No DIFF_ID was defined."))
  val phId: String = sys.env.getOrElse("PHID", throw new IllegalArgumentException("No PHID was defined."))
  val revisionId: String = sys.env.getOrElse("REVISION_ID", throw new IllegalArgumentException("No REVISION_ID was defined."))
  val buildUrl: String = sys.env.getOrElse("BUILD_URL", throw new IllegalArgumentException("No BUILD_URL was defined."))
  val buildTag: String = sys.env.getOrElse("BUILD_TAG", "here")

  try {
    phabricatorClient.reject(revisionId)
    jenkins()
    phabricatorClient.reportSuccess(diffId, phId, revisionId, buildUrl, buildTag)
  } catch {
    case NonFatal(e) =>
      phabricatorClient.reportFailure(diffId, phId, revisionId, buildUrl, buildTag, e.getMessage())
      throw e
  }
}

/**
 * Update DC/OS repository and triggers build of update DC/OS image.
 *
 * @param artifactUrl Url for the saved Marathon artifact.
 * @param sha1 The sah1 checksum of the artifact.
 */
@main
def updateDcosImage(artifactUrl: String, sha1: String): Unit = {
  upgrade.updateMarathon(artifactUrl, sha1, s"Change Marathon to $artifactUrl")
}

/**
 * The main pipeline target for builds on Jekins.
 */
@main
def jenkins(): Unit = {
  utils.stage("Provision") {
    provision.killStaleTestProcesses()
    provision.installMesos()
  }

  try {
    compileAndTest()
  } finally {
    zipSandboxLogs()    // Try to archive logs in any case
  }

  val artifacts = createAndUploadPackages()

  println(s"Master: ${utils.isMasterBuild}, GIT_BRANCH=${sys.env("GIT_BRANCH")}")
  if(utils.isMasterBuild) {
    val artifact = artifacts("tgz")
    updateDcosImage(artifact.downloadUrl, artifact.sha1)
  }
}
